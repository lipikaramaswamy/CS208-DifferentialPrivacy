}
# Probability density for Laplace distribution
#
# x numeric, value
# mu numeric, center of the distribution
# b numeric, spread
#
# return Density for elements of x
# example:
#
# x <- seq(-3, 3, length.out=61)
# dlap(x)
dlap <- function(x, mu=0, b=1) {
dens <- 0.5 * b * exp(-1 * abs(x - mu) / b)
return(dens)
}
# Laplace Cumulative Distribution Function
#
# Determines the probability a draw from a LaPlace distribution is less than
#    or equal to the specified value.
#
# x Numeric, the value(s) at which the user wants to know the CDF height.
# mu Numeric, the center of the LaPlace distribution, defaults to 0.
# b Numeric, the spread of the LaPlace distribution, defaults to 1.
#
# return Probability the LaPlace draw is less than or equal to \code{x}.
# example:
#
# x <- 0
# plap(x)
plap <- function(x, mu=0, b=1) {
cdf <- 0.5 + 0.5 * sgn(x - mu) * (1 - exp(-1 * (abs(x - mu) / b)))
return(cdf)
}
# Quantile function for Laplace distribution
#
# p Numeric, vector of probabilities
# mu numeric, center of the distribution
# b numeric, spread
# return Quantile function
# example:
#
# probs <- c(0.05, 0.50, 0.95)
# qlap(probs)
qlap <- function(p, mu=0, b=1) {
q <- ifelse(p < 0.5, mu + b * log(2 * p), mu - b * log(2 - 2 * p))
return(q)
}
sgn <- function(x) {
return(ifelse(x < 0, -1, 1))
}
library("foreign")
setwd("/Users/lipikaramaswamy/Documents/Harvard/CS208/cs208_lr/")
PUMSdata <- read.csv(file="data/FultonPUMS5full.csv")
data <- PUMSdata$educ    		# variable for means
data.x <- PUMSdata$educ			# x-variable for regression
data.y <- PUMSdata$income		# y-variable for regression
plot(data.x)
plot(data.y)
max(data.x)
max(data.y)
max(data.y) - min(data.y)
(max(data.y) - min(data.y))/nrow(data)
nrow(data)
nrow(data.x)
length(data.x)
rm(list=ls())		# Remove any objects in memory
par(mfrow=c(1,1))   # Rebuild fresh plot window, if previously divided
#### Parameters ####
# Random draw from Laplace distribution
#
# mu numeric, center of the distribution
# b numeric, spread
# size integer, number of draws
#
# return Random draws from Laplace distribution
# example:
#
# rlap(size=1000)
rlap = function(mu=0, b=1, size=1) {
p <- runif(size) - 0.5
draws <- mu - b * sgn(p) * log(1 - 2 * abs(p))
return(draws)
}
# Probability density for Laplace distribution
#
# x numeric, value
# mu numeric, center of the distribution
# b numeric, spread
#
# return Density for elements of x
# example:
#
# x <- seq(-3, 3, length.out=61)
# dlap(x)
dlap <- function(x, mu=0, b=1) {
dens <- 0.5 * b * exp(-1 * abs(x - mu) / b)
return(dens)
}
# Laplace Cumulative Distribution Function
#
# Determines the probability a draw from a LaPlace distribution is less than
#    or equal to the specified value.
#
# x Numeric, the value(s) at which the user wants to know the CDF height.
# mu Numeric, the center of the LaPlace distribution, defaults to 0.
# b Numeric, the spread of the LaPlace distribution, defaults to 1.
#
# return Probability the LaPlace draw is less than or equal to \code{x}.
# example:
#
# x <- 0
# plap(x)
plap <- function(x, mu=0, b=1) {
cdf <- 0.5 + 0.5 * sgn(x - mu) * (1 - exp(-1 * (abs(x - mu) / b)))
return(cdf)
}
# Quantile function for Laplace distribution
#
# p Numeric, vector of probabilities
# mu numeric, center of the distribution
# b numeric, spread
# return Quantile function
# example:
#
# probs <- c(0.05, 0.50, 0.95)
# qlap(probs)
qlap <- function(p, mu=0, b=1) {
q <- ifelse(p < 0.5, mu + b * log(2 * p), mu - b * log(2 - 2 * p))
return(q)
}
# Sign function
#
# Function to determine what the sign of the passed values should be.
#
# x numeric, value or vector or values
# return The sign of passed values
# example:
#
# sgn(rnorm(10))
sgn <- function(x) {
return(ifelse(x < 0, -1, 1))
}
library("foreign")
setwd("/Users/lipikaramaswamy/Documents/Harvard/CS208/cs208_lr/")
PUMSdata <- read.csv(file="data/FultonPUMS5full.csv")
data <- PUMSdata$educ    		# variable for means
data.x <- PUMSdata$educ			# x-variable for regression
data.y <- PUMSdata$income		# y-variable for regression
populationTrue <- mean(data)
## Bound/Censor/Clip a variable to a range
clip <- function(x, lower, upper){
x.clipped <- x
x.clipped[x.clipped<lower] <- lower
x.clipped[x.clipped>upper] <- upper
return(x.clipped)
}
## Sample with replacement from a vector
bootstrap <- function(x, y=NULL, n){
index <- sample(x=1:length(x), size=n, replace=TRUE)
if(is.null(y)){
return(x[index])
}else{
return(list(x=x[index], y=y[index]))
}
}
## Differentially private mean release
meanRelease <- function(x, lower, upper, epsilon){
n <- length(x)
# lower <- min(x)
# upper <- max(x)
sensitivity <- (upper - lower)/n
scale <- sensitivity / epsilon
x.clipped <- clip(x, lower, upper)
sensitiveValue <- mean(x.clipped) ## could be biased - if you always have income that's higher than the uppper bound,
##you're removing that data an dending up with a smaller mean
DPrelease <- sensitiveValue + rlap(mu=0, b=scale, size=1)
return(list(release=DPrelease, true=sensitiveValue))
}
## Differentially private regression slope release
regressionRelease <- function(y, x, ylower, yupper, xlower, xupper, epsilon){
x <- clip(x, xlower, xupper)
y <- clip(y, ylower, yupper)
n <- length(x)
sens.Sxy <- (max(data.x) - min(data.x))(max(data.y) - min(data.y))/length(data.x)
sens.Sxx <- (max(data.x) - min(data.x))^2/length(data.x)
scale.Sxy <- sens.Sxy / (epsilon/2)
scale.Sxx <- sens.Sxx / (epsilon/2)
sensitiveValue <- sum((x - mean(x))*(y - mean(y))) / sum((x - mean(x))^2)
release.Sxy <- sens.Sxy + rlap(mu = 0, scale = scale.Sxy)
release.Sxx <- sens.Sxx + rlap(mu = 0, scale = scale.Sxx)
postprocess.beta <- release.Sxy/release.Sxx
return(list(release=postprocess.beta, true=sensitiveValue))
}
n.sims <- 2000												# number of simulations to run
my.seq <- seq(from=log10(500), to=log10(5000), length=20)  	# make evenly spaced in logarithmic space
n.seq  <- round(10^my.seq)                                 	# round to integers
my.seq <- seq(from=log10(1), to=log10(0.1), length=4)     	# make evenly spaced in logarithmic space
ep.seq <- round(10^my.seq * 100) /100						# round to two decimal places
rawhistory <- matrix(NA, nrow=length(n.seq)*length(ep.seq)*n.sims, ncol=4)  # matrix to store results
agghistory <- matrix(NA, nrow=length(n.seq)*length(ep.seq), ncol=3)         # matrix to store results
rawcount <- 0												# counter
aggcount <- 0                                               # counter
for(i in 1:length(n.seq)){
for(j in 1:length(ep.seq)){
error <- NULL
aggcount <- aggcount + 1
for(k in 1:n.sims){
rawcount <- rawcount + 1
## Mean release
bootdata <- bootstrap(x=data, n=n.seq[i])
DPmean <- meanRelease(x=bootdata, epsilon=ep.seq[j], upper = 15, lower = 1)
release <- DPmean$release
sampleTrue <- DPmean$true
# Regression release
bootdata <- bootstrap(x=data.x, y=data.y, n=n.seq[i])
DPregression <- regressionRelease(x=bootdata$x,
y=bootdata$y, xlower= 0,
xupper=(max(data.x) - min(data.x))/length(data.x),
ylower=1,
yupper=(max(data.y) - min(data.y))/length(data.y),
epsilon=ep.seq[j])  # fix this
release <- DPregression$release
sampleTrue <- DPregression$true
error <- c(error, sampleTrue - release)
rawhistory[rawcount, 1] <- n.seq[i]
rawhistory[rawcount, 2] <- ep.seq[j]
rawhistory[rawcount, 3] <- release
rawhistory[rawcount, 4] <- sampleTrue
}
agghistory[aggcount, 1] <- n.seq[i]
agghistory[aggcount, 2] <- ep.seq[j]
agghistory[aggcount, 3] <- sqrt( mean( (error)^2 ) )  # RMSE
}
}
max(data.y)
for(i in 1:length(n.seq)){
for(j in 1:length(ep.seq)){
error <- NULL
aggcount <- aggcount + 1
for(k in 1:n.sims){
rawcount <- rawcount + 1
## Mean release
bootdata <- bootstrap(x=data, n=n.seq[i])
DPmean <- meanRelease(x=bootdata, epsilon=ep.seq[j], upper = 15, lower = 1)
release <- DPmean$release
sampleTrue <- DPmean$true
# Regression release
bootdata <- bootstrap(x=data.x, y=data.y, n=n.seq[i])
DPregression <- regressionRelease(x=bootdata$x,
y=bootdata$y, xlower= 0,
xupper=15,
ylower=1,
yupper=30000,
epsilon=ep.seq[j])  # fix this
release <- DPregression$release
sampleTrue <- DPregression$true
error <- c(error, sampleTrue - release)
rawhistory[rawcount, 1] <- n.seq[i]
rawhistory[rawcount, 2] <- ep.seq[j]
rawhistory[rawcount, 3] <- release
rawhistory[rawcount, 4] <- sampleTrue
}
agghistory[aggcount, 1] <- n.seq[i]
agghistory[aggcount, 2] <- ep.seq[j]
agghistory[aggcount, 3] <- sqrt( mean( (error)^2 ) )  # RMSE
}
}
## Differentially private regression slope release
regressionRelease <- function(y, x, ylower, yupper, xlower, xupper, epsilon){
x <- clip(x, xlower, xupper)
y <- clip(y, ylower, yupper)
n <- length(x)
sens.Sxy <- (max(x) - min(x))(max(y) - min(y))/length(x)
sens.Sxx <- (max(x) - min(x))^2/length(x)
scale.Sxy <- sens.Sxy / (epsilon/2)
scale.Sxx <- sens.Sxx / (epsilon/2)
sensitiveValue <- sum((x - mean(x))*(y - mean(y))) / sum((x - mean(x))^2)
release.Sxy <- sens.Sxy + rlap(mu = 0, scale = scale.Sxy)
release.Sxx <- sens.Sxx + rlap(mu = 0, scale = scale.Sxx)
postprocess.beta <- release.Sxy/release.Sxx
return(list(release=postprocess.beta, true=sensitiveValue))
}
n.sims <- 2000												# number of simulations to run
my.seq <- seq(from=log10(500), to=log10(5000), length=20)  	# make evenly spaced in logarithmic space
n.seq  <- round(10^my.seq)                                 	# round to integers
my.seq <- seq(from=log10(1), to=log10(0.1), length=4)     	# make evenly spaced in logarithmic space
ep.seq <- round(10^my.seq * 100) /100						# round to two decimal places
rawhistory <- matrix(NA, nrow=length(n.seq)*length(ep.seq)*n.sims, ncol=4)  # matrix to store results
agghistory <- matrix(NA, nrow=length(n.seq)*length(ep.seq), ncol=3)         # matrix to store results
rawcount <- 0												# counter
aggcount <- 0                                               # counter
for(i in 1:length(n.seq)){
for(j in 1:length(ep.seq)){
error <- NULL
aggcount <- aggcount + 1
for(k in 1:n.sims){
rawcount <- rawcount + 1
## Mean release
bootdata <- bootstrap(x=data, n=n.seq[i])
DPmean <- meanRelease(x=bootdata, epsilon=ep.seq[j], upper = 15, lower = 1)
release <- DPmean$release
sampleTrue <- DPmean$true
# Regression release
bootdata <- bootstrap(x=data.x, y=data.y, n=n.seq[i])
DPregression <- regressionRelease(x=bootdata$x,
y=bootdata$y, xlower= 0,
xupper=15,
ylower=1,
yupper=30000,
epsilon=ep.seq[j])  # fix this
release <- DPregression$release
sampleTrue <- DPregression$true
error <- c(error, sampleTrue - release)
rawhistory[rawcount, 1] <- n.seq[i]
rawhistory[rawcount, 2] <- ep.seq[j]
rawhistory[rawcount, 3] <- release
rawhistory[rawcount, 4] <- sampleTrue
}
agghistory[aggcount, 1] <- n.seq[i]
agghistory[aggcount, 2] <- ep.seq[j]
agghistory[aggcount, 3] <- sqrt( mean( (error)^2 ) )  # RMSE
}
}
## Differentially private regression slope release
regressionRelease <- function(y, x, ylower, yupper, xlower, xupper, epsilon){
x <- clip(x, xlower, xupper)
y <- clip(y, ylower, yupper)
n <- length(x)
sens.Sxy <- (max(x) - min(x))*(max(y) - min(y))/length(x)
sens.Sxx <- (max(x) - min(x))^2/length(x)
scale.Sxy <- sens.Sxy / (epsilon/2)
scale.Sxx <- sens.Sxx / (epsilon/2)
sensitiveValue <- sum((x - mean(x))*(y - mean(y))) / sum((x - mean(x))^2)
release.Sxy <- sens.Sxy + rlap(mu = 0, scale = scale.Sxy)
release.Sxx <- sens.Sxx + rlap(mu = 0, scale = scale.Sxx)
postprocess.beta <- release.Sxy/release.Sxx
return(list(release=postprocess.beta, true=sensitiveValue))
}
n.sims <- 2000												# number of simulations to run
my.seq <- seq(from=log10(500), to=log10(5000), length=20)  	# make evenly spaced in logarithmic space
n.seq  <- round(10^my.seq)                                 	# round to integers
my.seq <- seq(from=log10(1), to=log10(0.1), length=4)     	# make evenly spaced in logarithmic space
ep.seq <- round(10^my.seq * 100) /100						# round to two decimal places
rawhistory <- matrix(NA, nrow=length(n.seq)*length(ep.seq)*n.sims, ncol=4)  # matrix to store results
agghistory <- matrix(NA, nrow=length(n.seq)*length(ep.seq), ncol=3)         # matrix to store results
rawcount <- 0												# counter
aggcount <- 0                                               # counter
for(i in 1:length(n.seq)){
for(j in 1:length(ep.seq)){
error <- NULL
aggcount <- aggcount + 1
for(k in 1:n.sims){
rawcount <- rawcount + 1
## Mean release
bootdata <- bootstrap(x=data, n=n.seq[i])
DPmean <- meanRelease(x=bootdata, epsilon=ep.seq[j], upper = 15, lower = 1)
release <- DPmean$release
sampleTrue <- DPmean$true
# Regression release
bootdata <- bootstrap(x=data.x, y=data.y, n=n.seq[i])
DPregression <- regressionRelease(x=bootdata$x,
y=bootdata$y, xlower= 0,
xupper=15,
ylower=1,
yupper=30000,
epsilon=ep.seq[j])  # fix this
release <- DPregression$release
sampleTrue <- DPregression$true
error <- c(error, sampleTrue - release)
rawhistory[rawcount, 1] <- n.seq[i]
rawhistory[rawcount, 2] <- ep.seq[j]
rawhistory[rawcount, 3] <- release
rawhistory[rawcount, 4] <- sampleTrue
}
agghistory[aggcount, 1] <- n.seq[i]
agghistory[aggcount, 2] <- ep.seq[j]
agghistory[aggcount, 3] <- sqrt( mean( (error)^2 ) )  # RMSE
}
}
scale.Sxy <- sens.Sxy / (epsilon/2)
sens.Sxy <- (max(x.data) - min(x.data))*(max(y.data) - min(y.data))/length(x.data)
## Differentially private regression slope release
regressionRelease <- function(y, x, ylower, yupper, xlower, xupper, epsilon){
x <- clip(x, xlower, xupper)
y <- clip(y, ylower, yupper)
n <- length(x)
sens.Sxy <- (max(x) - min(x))*(max(y) - min(y))/length(x)
sens.Sxx <- (max(x) - min(x))^2/length(x)
scale.Sxy <- sens.Sxy / (epsilon/2)
scale.Sxx <- sens.Sxx / (epsilon/2)
sensitiveValue <- sum((x - mean(x))*(y - mean(y))) / sum((x - mean(x))^2)
release.Sxy <- sens.Sxy + rlap(mu = 0, scale = scale.Sxy)
release.Sxx <- sens.Sxx + rlap(mu = 0, scale = scale.Sxx)
postprocess.beta <- release.Sxy/release.Sxx
return(list(release=postprocess.beta, true=sensitiveValue))
}
n.sims <- 2000												# number of simulations to run
my.seq <- seq(from=log10(500), to=log10(5000), length=20)  	# make evenly spaced in logarithmic space
n.seq  <- round(10^my.seq)                                 	# round to integers
my.seq <- seq(from=log10(1), to=log10(0.1), length=4)     	# make evenly spaced in logarithmic space
ep.seq <- round(10^my.seq * 100) /100						# round to two decimal places
rawhistory <- matrix(NA, nrow=length(n.seq)*length(ep.seq)*n.sims, ncol=4)  # matrix to store results
agghistory <- matrix(NA, nrow=length(n.seq)*length(ep.seq), ncol=3)         # matrix to store results
rawcount <- 0												# counter
aggcount <- 0                                               # counter
for(i in 1:length(n.seq)){
for(j in 1:length(ep.seq)){
error <- NULL
aggcount <- aggcount + 1
for(k in 1:n.sims){
rawcount <- rawcount + 1
## Mean release
bootdata <- bootstrap(x=data, n=n.seq[i])
DPmean <- meanRelease(x=bootdata, epsilon=ep.seq[j], upper = 15, lower = 1)
release <- DPmean$release
sampleTrue <- DPmean$true
# Regression release
bootdata <- bootstrap(x=data.x, y=data.y, n=n.seq[i])
DPregression <- regressionRelease(x=bootdata$x,
y=bootdata$y, xlower= 0,
xupper=15,
ylower=1,
yupper=30000,
epsilon=ep.seq[j])  # fix this
release <- DPregression$release
sampleTrue <- DPregression$true
error <- c(error, sampleTrue - release)
rawhistory[rawcount, 1] <- n.seq[i]
rawhistory[rawcount, 2] <- ep.seq[j]
rawhistory[rawcount, 3] <- release
rawhistory[rawcount, 4] <- sampleTrue
}
agghistory[aggcount, 1] <- n.seq[i]
agghistory[aggcount, 2] <- ep.seq[j]
agghistory[aggcount, 3] <- sqrt( mean( (error)^2 ) )  # RMSE
}
}
## Differentially private regression slope release
regressionRelease <- function(y, x, ylower, yupper, xlower, xupper, epsilon){
x <- clip(x, xlower, xupper)
y <- clip(y, ylower, yupper)
n <- length(x)
sens.Sxy <- (max(x) - min(x))*(max(y) - min(y))/length(x)
sens.Sxx <- (max(x) - min(x))^2/length(x)
scale.Sxy <- sens.Sxy / (epsilon/2)
scale.Sxx <- sens.Sxx / (epsilon/2)
sensitiveValue <- sum((x - mean(x))*(y - mean(y))) / sum((x - mean(x))^2)
release.Sxy <- sens.Sxy + rlap(mu = 0, scale = scale.Sxy, size = 1)
release.Sxx <- sens.Sxx + rlap(mu = 0, scale = scale.Sxx, size = 1)
postprocess.beta <- release.Sxy/release.Sxx
return(list(release=postprocess.beta, true=sensitiveValue))
}
for(i in 1:length(n.seq)){
for(j in 1:length(ep.seq)){
error <- NULL
aggcount <- aggcount + 1
for(k in 1:n.sims){
rawcount <- rawcount + 1
## Mean release
bootdata <- bootstrap(x=data, n=n.seq[i])
DPmean <- meanRelease(x=bootdata, epsilon=ep.seq[j], upper = 15, lower = 1)
release <- DPmean$release
sampleTrue <- DPmean$true
# Regression release
bootdata <- bootstrap(x=data.x, y=data.y, n=n.seq[i])
DPregression <- regressionRelease(x=bootdata$x,
y=bootdata$y, xlower= 0,
xupper=15,
ylower=1,
yupper=30000,
epsilon=ep.seq[j])  # fix this
release <- DPregression$release
sampleTrue <- DPregression$true
error <- c(error, sampleTrue - release)
rawhistory[rawcount, 1] <- n.seq[i]
rawhistory[rawcount, 2] <- ep.seq[j]
rawhistory[rawcount, 3] <- release
rawhistory[rawcount, 4] <- sampleTrue
}
agghistory[aggcount, 1] <- n.seq[i]
agghistory[aggcount, 2] <- ep.seq[j]
agghistory[aggcount, 3] <- sqrt( mean( (error)^2 ) )  # RMSE
}
}
## Differentially private regression slope release
regressionRelease <- function(y, x, ylower, yupper, xlower, xupper, epsilon){
x <- clip(x, xlower, xupper)
y <- clip(y, ylower, yupper)
n <- length(x)
sens.Sxy <- (max(x) - min(x))*(max(y) - min(y))/length(x)
sens.Sxx <- (max(x) - min(x))^2/length(x)
scale.Sxy <- sens.Sxy / (epsilon/2)
scale.Sxx <- sens.Sxx / (epsilon/2)
sensitiveValue <- sum((x - mean(x))*(y - mean(y))) / sum((x - mean(x))^2)
release.Sxy <- sens.Sxy + rlap(mu = 0, b = scale.Sxy)
release.Sxx <- sens.Sxx + rlap(mu = 0, b = scale.Sxx)
postprocess.beta <- release.Sxy/release.Sxx
return(list(release=postprocess.beta, true=sensitiveValue))
}
par(mfcol=c(1,2))
color.palette<-rainbow(length(ep.seq), start=.7, end=.1)   # This creates a sequence of colors to use in subsequent plots, as in showchisq.r
for(j in 1:length(ep.seq)){
flag <- agghistory[,2] == ep.seq[j]
subhistory <- agghistory[flag,]
allylim <- c(0, max(agghistory[,3]))
if(j==1){
plot(subhistory[,1],subhistory[,3], ylim=allylim, type="l", col=color.palette[j], xlab="N", ylab="RMSE")
}else{
lines(subhistory[,1],subhistory[,3], col=color.palette[j])
}
}
