criticalValue <- nullDistribution[round(alpha*null.sims)] #find a point such that alpha percent of points are above that point
return(list(nullDist=nullDistribution, criticalVal=criticalValue))
}
## Visualize the null distribution
showdist <- function(x,criticalvalue, main="", bw="nrd0"){
testdens <- density(x, bw=bw)
plot(testdens, main=main, xlab="Test Statistic")
semi.blue <- rgb(0,90,239,180,maxColorValue=255)          # Slightly transparent colors
semi.red  <- rgb(239,90,0,180,maxColorValue=255)
flag <- testdens$x < criticalvalue
polygon( c(min(testdens$x), testdens$x[flag], criticalvalue), y=c(0, testdens$y[flag], 0), col=semi.blue)
polygon( c(criticalvalue, testdens$x[!flag], max(testdens$x)), y=c(0, testdens$y[!flag], 0), col=semi.red)
abline(v=criticalvalue, lwd=1.5)
accept.frac <- round(100*mean(x>criticalvalue))/100
text(x=criticalvalue, y=0.8*max(testdens$y), labels=paste("OUT "), pos=2)
text(x=criticalvalue, y=0.8*max(testdens$y), labels=paste(" IN"), pos=4)
text(x=criticalvalue, y=0.7*max(testdens$y), labels=paste(accept.frac), pos=4)
}
## Find the null distribution for test1
output <- nullDistribution(fun=test.Homer, population.prob=population.prob)
testdist <- output$nullDist
criticalValue <- output$criticalVal
showdist(testdist, criticalValue, main="Null Distribution with Critical Value")
#### Export graph to .pdf ####
dev.copy2pdf(file="./figs/nullDistribution.pdf")
# stop()
## Simulate
history <- matrix(NA, nrow=n.sims, ncol=9)														# Matrix to store results
myalpha <-0.01
nullDist.Homer<-nullDistribution(fun=test.Homer, population.prob=population.prob, alpha=myalpha)	# Find null distributions
nullDist.Dwork<-nullDistribution(fun=test.Dwork, population.prob=population.prob, alpha=myalpha)
for(i in 1:n.sims){
# Simulate data
sample <- rmvbernoulli(n=n.samples, prob=population.prob)
sample.mean <- apply(sample, MARGIN=2, FUN=mean)
alice <- sample[1,]
nullAlice <- rmvbernoulli(n=1, prob=population.prob)
referent <- rmvbernoulli(n=1, prob=population.prob)
# Conduct tests
test.alice.Homer <- test.Homer(alice=alice, sample.mean=sample.mean, population.mean=population.mean, referent=referent)
test.alice.Dwork <- test.Dwork(alice=alice, sample.mean=sample.mean, population.mean=population.mean, referent=referent)
test.nullAlice.Homer <- test.Homer(alice=nullAlice, sample.mean=sample.mean, population.mean=population.mean, referent=referent)
test.nullAlice.Dwork <- test.Dwork(alice=nullAlice, sample.mean=sample.mean, population.mean=population.mean, referent=referent)
# Store simulated values
history[i,1]<-i
history[i,2]<-test.alice.Homer
history[i,3]<-test.alice.Homer>nullDist.Homer$criticalVal
history[i,4]<-test.nullAlice.Homer
history[i,5]<-test.nullAlice.Homer>nullDist.Homer$criticalVal
history[i,6]<-test.alice.Dwork
history[i,7]<-test.alice.Dwork>nullDist.Dwork$criticalVal
history[i,8]<-test.nullAlice.Dwork
history[i,9]<-test.nullAlice.Dwork>nullDist.Dwork$criticalVal
}
#### Export graph to .pdf ####
par(mfrow=c(2,2))
showdist(history[,2], criticalvalue=nullDist.Homer$criticalVal, main="Homer Alice", bw=0.5)
showdist(history[,4], criticalvalue=nullDist.Homer$criticalVal, main="Homer Null", bw=0.5)
Tvalue <- sqrt(8*k.attributes * log(1/myalpha))
showdist(history[,6], criticalvalue=nullDist.Dwork$criticalVal, main="Dwork Alice", bw=0.5)
abline(v=Tvalue, col="red", lty=2)
showdist(history[,8], criticalvalue=nullDist.Dwork$criticalVal, main="Dwork Null", bw=0.5)
abline(v=Tvalue, col="red", lty=2)
dev.copy2pdf(file="./figs/membershipAttack.pdf")
p5 <- ggplot(rounding.for.plots, aes(x = parameter.range, y = acc.gaussian)) +
geom_point() +
geom_hline(0.5, linetype, linetype="dashed", color = "darkcyan") +
labs(x = "R", y = 'Accuracy', title = 'Accuracy') +
theme(plot.title = element_text(hjust = 0.5))
library(caret)
library(plyr)
library(dplyr)
library(ggplot2)
library(gridExtra)
## number of queries
k.trials <- 200
## number of rows in dataset
n <- 100
setwd("/Users/lipikaramaswamy/Documents/Harvard/CS208/cs208_lr/")
pums <- read.csv("data/FultonPUMS5sample100.csv")
# subset data to that which is available to attacker
available.pums = select(pums, uscitizen, sex, age, educ, latino, black, asian, married,
divorced,children,disability,militaryservice,employed,englishability)
# make new column to contain randomly hashed values that determine membership to the random subsets
available.pums$subset.indicator<-NA
# set aside sensitive data:
sensitive.data <- pums[, "uscitizen"]
# Chose random large prime number
P = 491
# Make vector of all integers up to P
prime.options <- seq(from=0, to=P-1, by=1)
runQuery <- function(df, rounding = FALSE, R = 0, gaussian = FALSE, gaussian.sigma = 0, subsample = FALSE, subsample.size = 1){
## random subset creation
r = sample(prime.options, size=13, replace = FALSE)
mat.of.obs = as.matrix(available.pums[,2:14])
p = (mat.of.obs %*% r) %% P %% 2
df$subset.indicator = p
## subsetting and returning the sum
subset = df[df$subset.indicator == 1,]
sum <- sum(subset$uscitizen)
index = as.numeric(rownames(subset))
## round if specified
if (rounding == TRUE){
round <- round_any(sum, R)
return(list(sum=round, index=index, truesum = sum))
}
## add gaussian noise if specified
if (gaussian == TRUE){
noisy <- sum + rnorm(1,0,(gaussian.sigma))
return(list(sum=noisy, index=index, truesum = sum))
}
## subsample and scale query result if specified
if (subsample == TRUE){
## subset df to randomly hashed 1s
# subset = df[df$subset.indicator == 1,]
# index = as.numeric(rownames(subset))
subsample.index <- sample(x=1:nrow(df), size=subsample.size, replace = FALSE)
subset <- df[subsample.index,]
subsetsum <- sum(subset$subset.indicator * subset$uscitizen) * (nrow(df)/subsample.size)
return(list(sum=subsetsum, index=index, truesum = sum))
}
## if none of the defense mechanisms are specified, return true sum
if (rounding == FALSE & rounding == FALSE & gaussian == FALSE){
return(list(sum=sum, index = index, truesum = sum))
}
}
p5 <- ggplot(rounding.for.plots, aes(x = parameter.range, y = acc.gaussian)) +
geom_point() +
geom_hline(0.5, linetype, linetype="dashed", color = "darkcyan") +
labs(x = "R", y = 'Accuracy', title = 'Accuracy') +
theme(plot.title = element_text(hjust = 0.5))
runQuery <- function(df, rounding = FALSE, R = 0, gaussian = FALSE, gaussian.sigma = 0, subsample = FALSE, subsample.size = 1){
## random subset creation
r = sample(prime.options, size=13, replace = FALSE)
mat.of.obs = as.matrix(available.pums[,2:14])
p = (mat.of.obs %*% r) %% P %% 2
df$subset.indicator = p
## subsetting and returning the sum
subset = df[df$subset.indicator == 1,]
sum <- sum(subset$uscitizen)
index = as.numeric(rownames(subset))
## round if specified
if (rounding == TRUE){
round <- round_any(sum, R)
return(list(sum=round, index=index, truesum = sum))
}
## add gaussian noise if specified
if (gaussian == TRUE){
noisy <- sum + rnorm(1,0,(gaussian.sigma))
return(list(sum=noisy, index=index, truesum = sum))
}
## subsample and scale query result if specified
if (subsample == TRUE){
subsample.index <- sample(x=1:nrow(df), size=subsample.size, replace = FALSE)
subset <- df[subsample.index,]
subsetsum <- sum(subset$subset.indicator * subset$uscitizen) * (nrow(df)/subsample.size)
return(list(sum=subsetsum, index=index, truesum = sum))
}
## if none of the defense mechanisms are specified, return true sum
if (rounding == FALSE & rounding == FALSE & gaussian == FALSE){
return(list(index = index, truesum = sum))
}
}
## set varnames
xnames <- paste("x", 1:n, sep="")
varnames<- c("y", xnames)
## Make formula
formula <- paste(xnames, collapse=" + ")
formula <- paste("y ~ ", formula, "-1")
formula <- as.formula(formula)
## matrix to contain results of the queries and indices
history.rounding <- matrix(NA, nrow=k.trials, ncol=100+2)
history.gaussian <- matrix(NA, nrow=k.trials, ncol=100+2)
history.subsamp <- matrix(NA, nrow=k.trials, ncol=100+2)
## set parameter ranges to loop thru
parameter.range <- seq(from=1, to=100, by=1)
RMSE.matrix <- matrix (, nrow = 100, ncol = 10)
acc.matrix <- matrix (, nrow = 100, ncol = 10)
for(b in 1:10){
for(a in parameter.range){
## build matrix for regression
for(i in 1:k.trials){
res <- runQuery(df=available.pums, rounding = TRUE, R = a)
indicator <- 1:n %in% res$index
indicator <- as.numeric(indicator)
history.rounding[i,] <- c(res$truesum, res$sum, indicator)
}
## Convert matrix into data frame
release.data.rounding <- as.data.frame(history.rounding[,2:102])
names(release.data.rounding) <- varnames
## Run reg and get estimates
output.rounding <- lm(formula, data=release.data.rounding)
estimates.rounding <- output.rounding$coef
RMSE.matrix[a,b] <- postResample(history.rounding[,1], history.rounding[,2])[1]
correct.preds <- ((estimates.gaussian>0.5) == sensitive.data)
acc.matrix[a,b] <- sum(correct.preds)/100
}
RMSE.rounding <-rowMeans(RMSE.matrix)
acc.rounding <-rowMeans(acc.matrix)
}
for(b in 1:10){
for(a in parameter.range){
## build matrix for regression
for(i in 1:k.trials){
res <- runQuery(df=available.pums, gaussian = TRUE, gaussian.sigma = a)
indicator <- 1:n %in% res$index                         # convert indices into a series of boolean/dummy variables
indicator <- as.numeric(indicator)
history.gaussian[i,] <- c(res$truesum, res$sum, indicator)
}
## Convert matrix into data frame
release.data.gaussian <- as.data.frame(history.gaussian[,2:102])
names(release.data.gaussian) <- varnames
## Run reg and get estimates
output.gaussian <- lm(formula, data=release.data.gaussian)
estimates.gaussian <- output.gaussian$coef
RMSE.matrix[a,b] <- postResample(history.gaussian[,1], history.gaussian[,2])[1]
correct.preds <- (estimates.gaussian>0.5) & (sensitive.data==1) | (estimates.gaussian<0.5) & (sensitive.data==0)
acc.matrix[a,b] <- sum(correct.preds)/100
# estimated
# correct.preds1 <- ((estimates.gaussian>0.5) == sensitive.data)
# acc.matrix1[a,b] <- sum(correct.preds1)/100
}
RMSE.gaussian <-rowMeans(RMSE.matrix)
acc.gaussian <-rowMeans(acc.matrix)
}
## PLOT Results
rounding.for.plots = data.frame(parameter.range, RMSE.rounding, acc.rounding)
gaussian.for.plots = data.frame(parameter.range, RMSE.gaussian, acc.gaussian)
p4 <- ggplot(gaussian.for.plots, aes(x = parameter.range, y = RMSE.gaussian)) +
geom_point() +
labs(x = "R", y = 'RMSE', title = 'Root Mean Squared Error (RMSE)') +
theme(plot.title = element_text(hjust = 0.5))
p5 <- ggplot(rounding.for.plots, aes(x = parameter.range, y = acc.gaussian)) +
geom_point() +
geom_hline(0.5, linetype, linetype="dashed", color = "darkcyan") +
labs(x = "R", y = 'Accuracy', title = 'Accuracy') +
theme(plot.title = element_text(hjust = 0.5))
gaussian.for.plots = data.frame(parameter.range, RMSE.gaussian, acc.gaussian)
p4 <- ggplot(gaussian.for.plots, aes(x = parameter.range, y = RMSE.gaussian)) +
geom_point() +
labs(x = "R", y = 'RMSE', title = 'Root Mean Squared Error (RMSE)') +
theme(plot.title = element_text(hjust = 0.5))
p5 <- ggplot(gaussian.for.plots, aes(x = parameter.range, y = acc.gaussian)) +
geom_point() +
geom_hline(0.5, linetype, linetype="dashed", color = "darkcyan") +
labs(x = "R", y = 'Accuracy', title = 'Accuracy') +
theme(plot.title = element_text(hjust = 0.5))
p5 <- ggplot(gaussian.for.plots, aes(x = parameter.range, y = acc.gaussian)) +
geom_point() +
# geom_hline(0.5, linetype, linetype="dashed", color = "darkcyan") +
labs(x = "R", y = 'Accuracy', title = 'Accuracy') +
theme(plot.title = element_text(hjust = 0.5))
p5 <- ggplot(gaussian.for.plots, aes(x = parameter.range, y = acc.gaussian)) +
geom_point() +
geom_hline(y = 0.5, linetype, linetype="dashed", color = "darkcyan") +
labs(x = "R", y = 'Accuracy', title = 'Accuracy') +
theme(plot.title = element_text(hjust = 0.5))
p5 <- ggplot(gaussian.for.plots, aes(x = parameter.range, y = acc.gaussian)) +
geom_point() +
geom_hline(y = 0.5, linetype="dashed", color = "darkcyan") +
labs(x = "R", y = 'Accuracy', title = 'Accuracy') +
theme(plot.title = element_text(hjust = 0.5))
p5 <- ggplot(gaussian.for.plots, aes(x = parameter.range, y = acc.gaussian)) +
geom_point() +
geom_hline(0.5, linetype="dashed", color = "darkcyan") +
labs(x = "R", y = 'Accuracy', title = 'Accuracy') +
theme(plot.title = element_text(hjust = 0.5))
p5 <- ggplot(gaussian.for.plots, aes(x = parameter.range, y = acc.gaussian)) +
geom_point() +
geom_hline(yintercept = 0.5, linetype="dashed", color = "darkcyan") +
labs(x = "R", y = 'Accuracy', title = 'Accuracy') +
theme(plot.title = element_text(hjust = 0.5))
p6 <- ggplot(gaussian.for.plots, aes(x = RMSE.gaussian, y = acc.gaussian)) +
geom_point() +
labs(x = "RMSE", y = 'Accuracy', title = 'Accuracy vs. RMSE') +
theme(plot.title = element_text(hjust = 0.5))
plots.gaussian = grid.arrange(p4, p5, p6, nrow = 1)
gaussian.for.plots = data.frame(parameter.range, RMSE.gaussian, acc.gaussian)
p4 <- ggplot(gaussian.for.plots, aes(x = parameter.range, y = RMSE.gaussian)) +
geom_point() +
labs(x = "R", y = 'RMSE', title = 'Root Mean Squared Error (RMSE)') +
theme(plot.title = element_text(hjust = 0.5))
p5 <- ggplot(gaussian.for.plots, aes(x = parameter.range, y = acc.gaussian)) +
geom_point() +
geom_hline(yintercept = 0.5, color = "darkcyan") +
labs(x = "R", y = 'Accuracy', title = 'Accuracy') +
theme(plot.title = element_text(hjust = 0.5))
p6 <- ggplot(gaussian.for.plots, aes(x = RMSE.gaussian, y = acc.gaussian)) +
geom_point() +
labs(x = "RMSE", y = 'Accuracy', title = 'Accuracy vs. RMSE') +
theme(plot.title = element_text(hjust = 0.5))
plots.gaussian = grid.arrange(p4, p5, p6, nrow = 1)
ggsave(filename = 'gaussian_plots.pdf', plot = plots.gaussian, width = 11, height = 5, units = 'in')
for(b in 1:10){
for(a in parameter.range){
## build matrix for regression
for(i in 1:k.trials){
res <- runQuery(df=available.pums, subsample = TRUE, subsample.size = a)
indicator <- 1:n %in% res$index                         # convert indices into a series of boolean/dummy variables
indicator <- as.numeric(indicator)
history.subsamp[i,] <- c(res$truesum, res$sum, indicator)                    # save into our results matrix
}
## Convert matrix into data frame
release.data.subsamp <- as.data.frame(history.subsamp[,2:102])
names(release.data.subsamp) <- varnames
## Run reg and get estimates
output.subsamp <- lm(formula, data=release.data.subsamp)
estimates.subsamp <- output.subsamp$coef
RMSE.matrix[a,b] <- postResample(history.subsamp[,1], history.subsamp[,2])[1]
correct.preds <- (estimates.subsamp>0.5) & (sensitive.data==1) | (estimates.subsamp<0.5) & (sensitive.data==0)
acc.matrix[a,b] <- sum(correct.preds)/100
}
RMSE.subsamp <-rowMeans(RMSE.matrix)
acc.subsamp <-rowMeans(acc.matrix)
}
subsamp.for.plots = data.frame(parameter.range, RMSE.subsamp, acc.subsamp)
p7 <- ggplot(subsamp.for.plots, aes(x = parameter.range, y = RMSE.subsamp)) +
geom_point() +
labs(x = "R", y = 'RMSE', title = 'Root Mean Squared Error (RMSE)') +
theme(plot.title = element_text(hjust = 0.5))
p8 <- ggplot(subsamp.for.plots, aes(x = parameter.range, y = acc.subsamp)) +
geom_point() +
geom_hline(yintercept = 0.5, color = "darkcyan") +
labs(x = "R", y = 'Accuracy', title = 'Accuracy') +
theme(plot.title = element_text(hjust = 0.5))
p9 <- ggplot(subsamp.for.plots, aes(x = RMSE.subsamp, y = acc.subsamp)) +
geom_point() +
labs(x = "RMSE", y = 'Accuracy', title = 'Accuracy vs. RMSE') +
theme(plot.title = element_text(hjust = 0.5))
plots.subsampling = grid.arrange(p7, p8, p9, nrow = 1)
ggsave(filename = 'subsampling_plots.pdf', plot = plots.subsampling, width = 11, height = 5, units = 'in')
for(b in 1:10){
for(a in parameter.range){
## build matrix for regression
for(i in 1:k.trials){
res <- runQuery(df=available.pums, rounding = TRUE, R = a)
indicator <- 1:n %in% res$index
indicator <- as.numeric(indicator)
history.rounding[i,] <- c(res$truesum, res$sum, indicator)
}
## Convert matrix into data frame
release.data.rounding <- as.data.frame(history.rounding[,2:102])
names(release.data.rounding) <- varnames
## Run reg and get estimates
output.rounding <- lm(formula, data=release.data.rounding)
estimates.rounding <- output.rounding$coef
RMSE.matrix[a,b] <- postResample(history.rounding[,1], history.rounding[,2])[1]
correct.preds <- ((estimates.gaussian>0.5) == sensitive.data)
acc.matrix[a,b] <- sum(correct.preds)/100
}
RMSE.rounding <-rowMeans(RMSE.matrix)
acc.rounding <-rowMeans(acc.matrix)
}
rounding.for.plots = data.frame(parameter.range, RMSE.rounding, acc.rounding)
p1 <- ggplot(rounding.for.plots, aes(x = parameter.range, y = RMSE.rounding)) +
geom_point() +
labs(x = "R", y = 'RMSE', title = 'Root Mean Squared Error (RMSE)') +
theme(plot.title = element_text(hjust = 0.5))
p2 <- ggplot(rounding.for.plots, aes(x = parameter.range, y = acc.rounding)) +
geom_point() +
geom_hline(yintercept = 0.5, color = "darkcyan") +
labs(x = "R", y = 'Accuracy', title = 'Accuracy') +
theme(plot.title = element_text(hjust = 0.5))
p3 <- ggplot(rounding.for.plots, aes(x = RMSE.rounding, y = acc.rounding)) +
geom_point() +
labs(x = "RMSE", y = 'Accuracy', title = 'Accuracy vs. RMSE') +
theme(plot.title = element_text(hjust = 0.5))
plots.rounding = grid.arrange(p1, p2, p3, nrow = 1)
rm(list=ls())		# Remove any objects in memory
par(mfrow=c(1,1))   # Rebuild fresh plot window, if previously divided
#### Parameters ####
set.seed(123)
k.attributes <- 100
n.sims<- 10000
n.samples <- 10
null.sims <- 1000
## Generate underlying population attributes
population.prob <- runif(n=k.attributes, min=0, max=1)
population.prob
population.mean <- 2*(population.prob-0.5)              # Because we are recoding to {-1,1} in next function
popilation.mean
population.mean
plot(population.prob)
hist(population.mean)
hist(population.prob)
## A utility function to create data from the population
rmvbernoulli <- function(n=1, prob){
history <- matrix(NA, nrow=n, ncol=length(prob))
for(i in 1:n){
x<- rbinom(n=length(prob), size=1, prob=prob)
x[x==0] <- -1      								# Transform from {0,1} to {-1,1}
history[i,] <- x
}
return(history)
}
## Some potential test statistics
test.Homer <- function(alice, sample.mean, population.mean, referent){
test.statistic <- sum(abs(alice - population.mean) - abs(alice - sample.mean))
return(test.statistic)
}
# This is the Dwork et al. test using the population means
test.Dwork <- function(alice, sample.mean, population.mean, referent){
test.statistic <- sum(alice * sample.mean) - sum(population.mean * sample.mean)
return(test.statistic)
}
## A null distribution and critical value generator
nullDistribution <- function(null.sims=1000, alpha=0.05, fun, population.prob){
population.mean <- 2*(population.prob-0.5)
hold <- rep(NA,null.sims)
for(i in 1:null.sims){
sample <- rmvbernoulli(n=n.samples, prob=population.prob)
nullAlice <- rmvbernoulli(n=1, prob=population.prob)
referent <- rmvbernoulli(n=1, prob=population.prob)
sample.mean <- apply(sample, MARGIN=2, FUN=mean)
hold[i] <- eval(fun(alice=nullAlice, sample.mean=sample.mean, population.mean=population.mean, referent=referent))
}
nullDistribution <- sort(hold, decreasing=TRUE)
criticalValue <- nullDistribution[round(alpha*null.sims)] #find a point such that alpha percent of points are above that point
return(list(nullDist=nullDistribution, criticalVal=criticalValue))
}
showdist <- function(x,criticalvalue, main="", bw="nrd0"){
testdens <- density(x, bw=bw)
plot(testdens, main=main, xlab="Test Statistic")
semi.blue <- rgb(0,90,239,180,maxColorValue=255)          # Slightly transparent colors
semi.red  <- rgb(239,90,0,180,maxColorValue=255)
flag <- testdens$x < criticalvalue
polygon( c(min(testdens$x), testdens$x[flag], criticalvalue), y=c(0, testdens$y[flag], 0), col=semi.blue)
polygon( c(criticalvalue, testdens$x[!flag], max(testdens$x)), y=c(0, testdens$y[!flag], 0), col=semi.red)
abline(v=criticalvalue, lwd=1.5)
accept.frac <- round(100*mean(x>criticalvalue))/100
text(x=criticalvalue, y=0.8*max(testdens$y), labels=paste("OUT "), pos=2)
text(x=criticalvalue, y=0.8*max(testdens$y), labels=paste(" IN"), pos=4)
text(x=criticalvalue, y=0.7*max(testdens$y), labels=paste(accept.frac), pos=4)
}
## Find the null distribution for test1
output <- nullDistribution(fun=test.Homer, population.prob=population.prob)
population.prob
rmvbernoulli(n=1, prob=population.prob)
rmvbernoulli(n=n.samples, prob=population.prob)
apply(sample, MARGIN=2, FUN=mean)
sample <- rmvbernoulli(n=n.samples, prob=population.prob)
nullAlice <- rmvbernoulli(n=1, prob=population.prob)
referent <- rmvbernoulli(n=1, prob=population.prob)
sample.mean <- apply(sample, MARGIN=2, FUN=mean)
sample.mean
## Find the null distribution for test1
output <- nullDistribution(fun=test.Homer, population.prob=population.prob)
testdist <- output$nullDist
criticalValue <- output$criticalVal
showdist(testdist, criticalValue, main="Null Distribution with Critical Value")
myalpha <-0.01
nullDist.Homer<-nullDistribution(fun=test.Homer, population.prob=population.prob, alpha=myalpha)	# Find null distributions
nullDist.Dwork<-nullDistribution(fun=test.Dwork, population.prob=population.prob, alpha=myalpha)
for(i in 1:n.sims){
# Simulate data
sample <- rmvbernoulli(n=n.samples, prob=population.prob)
sample.mean <- apply(sample, MARGIN=2, FUN=mean)
alice <- sample[1,]
nullAlice <- rmvbernoulli(n=1, prob=population.prob)
referent <- rmvbernoulli(n=1, prob=population.prob)
# Conduct tests
test.alice.Homer <- test.Homer(alice=alice, sample.mean=sample.mean, population.mean=population.mean, referent=referent)
test.alice.Dwork <- test.Dwork(alice=alice, sample.mean=sample.mean, population.mean=population.mean, referent=referent)
test.nullAlice.Homer <- test.Homer(alice=nullAlice, sample.mean=sample.mean, population.mean=population.mean, referent=referent)
test.nullAlice.Dwork <- test.Dwork(alice=nullAlice, sample.mean=sample.mean, population.mean=population.mean, referent=referent)
# Store simulated values
history[i,1]<-i
history[i,2]<-test.alice.Homer
history[i,3]<-test.alice.Homer>nullDist.Homer$criticalVal
history[i,4]<-test.nullAlice.Homer
history[i,5]<-test.nullAlice.Homer>nullDist.Homer$criticalVal
history[i,6]<-test.alice.Dwork
history[i,7]<-test.alice.Dwork>nullDist.Dwork$criticalVal
history[i,8]<-test.nullAlice.Dwork
history[i,9]<-test.nullAlice.Dwork>nullDist.Dwork$criticalVal
}
## Simulate
history <- matrix(NA, nrow=n.sims, ncol=9)														# Matrix to store results
myalpha <-0.01
nullDist.Homer<-nullDistribution(fun=test.Homer, population.prob=population.prob, alpha=myalpha)	# Find null distributions
nullDist.Dwork<-nullDistribution(fun=test.Dwork, population.prob=population.prob, alpha=myalpha)
for(i in 1:n.sims){
# Simulate data
sample <- rmvbernoulli(n=n.samples, prob=population.prob)
sample.mean <- apply(sample, MARGIN=2, FUN=mean)
alice <- sample[1,]
nullAlice <- rmvbernoulli(n=1, prob=population.prob)
referent <- rmvbernoulli(n=1, prob=population.prob)
# Conduct tests
test.alice.Homer <- test.Homer(alice=alice, sample.mean=sample.mean, population.mean=population.mean, referent=referent)
test.alice.Dwork <- test.Dwork(alice=alice, sample.mean=sample.mean, population.mean=population.mean, referent=referent)
test.nullAlice.Homer <- test.Homer(alice=nullAlice, sample.mean=sample.mean, population.mean=population.mean, referent=referent)
test.nullAlice.Dwork <- test.Dwork(alice=nullAlice, sample.mean=sample.mean, population.mean=population.mean, referent=referent)
# Store simulated values
history[i,1]<-i
history[i,2]<-test.alice.Homer
history[i,3]<-test.alice.Homer>nullDist.Homer$criticalVal
history[i,4]<-test.nullAlice.Homer
history[i,5]<-test.nullAlice.Homer>nullDist.Homer$criticalVal
history[i,6]<-test.alice.Dwork
history[i,7]<-test.alice.Dwork>nullDist.Dwork$criticalVal
history[i,8]<-test.nullAlice.Dwork
history[i,9]<-test.nullAlice.Dwork>nullDist.Dwork$criticalVal
}
par(mfrow=c(2,2))
showdist(history[,2], criticalvalue=nullDist.Homer$criticalVal, main="Homer Alice", bw=0.5)
showdist(history[,4], criticalvalue=nullDist.Homer$criticalVal, main="Homer Null", bw=0.5)
Tvalue <- sqrt(8*k.attributes * log(1/myalpha))
showdist(history[,6], criticalvalue=nullDist.Dwork$criticalVal, main="Dwork Alice", bw=0.5)
abline(v=Tvalue, col="red", lty=2)
showdist(history[,8], criticalvalue=nullDist.Dwork$criticalVal, main="Dwork Null", bw=0.5)
abline(v=Tvalue, col="red", lty=2)
